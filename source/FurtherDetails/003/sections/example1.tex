\section{How to meet the coding standards}\label{sec:example}

The following code example exhibits all that is defined as a good coding
standard and how code should be written for inclusion within the UM.

The example is highlighted with references (section links) to the remainder of this document 
which provide further details on the standard and style used. 

\begin{longtable}{lr} \\
\verb|example_mod.F90|   &  \ref{sec:progunit} \\
\verb|| & \\  
\verb|| & \\  
\verb|| & \\ 
\verb|! *****************************COPYRIGHT*******************************| &  \ref{sec:Copyright} \\  
\verb|! (C) Crown copyright Met Office. All rights reserved.                 | & \\
\verb|! For further details please refer to the file COPYRIGHT.txt           | & \\
\verb|! which you should have received as part of this distribution.         | & \\
\verb|! *****************************COPYRIGHT*******************************| & \\
\verb|!| & \\
\verb|! An example routine depicting how one should construct new code | & \\
\verb|! to meet the UMDP3 coding standards. | & \ref{sec:Copyright}\\ 
\verb|!| & \\
\verb|MODULE example_mod | & \ref{sec:80cols} \ref{sec:fortstyle} \ref{sec:modules} \\
\verb| | & \\
\verb|IMPLICIT NONE| & \ref{sec:declare}\\
\verb| | & \\
\verb|! Description:| & \ref{sec:Copyright} \\  
\verb|!   A noddy routine that illustrates the way to apply the UMDP3 | & \\  
\verb|!   coding standards to new code to help code developers | & \\  
\verb|!   pass code reviews. | & \\  
\verb|! | & \\
\verb|! Method:| & \\  
\verb|!   In this routine we apply many of the UMDP3 features| & \ref{sec:Copyright}\\  
\verb|!   to construct a simple routine. The references on the RHS take the reader| & \\ 
\verb|!   to the appropriate section of the UMDP3 guide with further details.  | & \\ 
\verb|!| & \\  
\verb|! Code Owner: Please refer to the UM file CodeOwners.txt| & \ref{sec:Copyright}\\  
\verb|! This file belongs in section: Control | & \\  
\verb|!| & \\  
\verb|! Code description:| & \ref{sec:Copyright}\\  
\verb|!   Language: Fortran 2003.| & \\  
\verb|!   This code is written to UMDP3 standards.| & \\  
\verb|| & \\  
\verb|CHARACTER(LEN=*), PARAMETER, PRIVATE :: ModuleName='EXAMPLE_MOD' | & \ref{sec:drhook} \\
\verb| | & \\
\verb|CONTAINS| & \ref{sec:progunit}\\  
\verb|| & \\  
\verb|! Subroutine Interface:| & \\  
\verb|SUBROUTINE example (xlen,ylen,l_unscale,input1,input2 &  |     & \ref{sec:contd}\\
\verb|                                       output, l_loud_opt) |  \\  
\verb|| & \\  
\verb|! Description:| & \\  
\verb|!   Nothing further to add to module description.  | & \ref{sec:Copyright}\\  
\verb|USE atmos_constants_mod,    ONLY: r                | & \ref{sec:modules}\\
\verb|USE ereport_mod,            ONLY: ereport          | & \\
\verb|USE parkind1,               ONLY: jpim, jprb       | & \ref{sec:drhook}\\ 
\verb|USE umprintMgr,             ONLY: umprint,ummessage,PrNorm | &  \ref{sec:format}\\
\verb|USE errormessagelength_mod, ONLY: errormessagelength | & \\
\verb|USE yomhook,                ONLY: lhook, dr_hook   | & \ref{sec:drhook}\\  
\verb|| & \\  
\verb|IMPLICIT NONE| & \ref{sec:declare} \\  
\verb|| & \\  
\verb|! Subroutine arguments| & \\  
\verb|INTEGER, INTENT(IN)  :: xlen  !Length of first dimension of the arrays.  | &  \ref{sec:declare}\\  
\verb|INTEGER, INTENT(IN)  :: ylen  !Length of second dimension of the arrays. | & \\       
\verb|| & \\  
\verb|LOGICAL, INTENT(IN)  :: l_unscale  ! switch scaling off.| & \\ 
\verb|| & \\  
\verb|REAL, INTENT(IN)     :: input1(xlen, ylen) !First input array| &  \ref{sec:declare}\\  
\verb|| & \\ 
\verb|REAL, INTENT(IN OUT) :: input2(xlen, ylen) !Second input array | & \ref{sec:declare}\\  
\verb|REAL, INTENT(OUT)    :: output(xlen, ylen) !Contains the result| & \ref{sec:declare}\\  
\verb|| & \\  
\verb|LOGICAL, INTENT(IN), OPTIONAL :: l_loud_opt !optional debug flag| & \ref{sec:declare}\\  
\verb|| & \\ 
\verb|! Local variables| & \\  
\verb|INTEGER(KIND=jpim), PARAMETER :: zhook_in  = 0  ! DrHook tracing entry| &\ref{sec:declare} \ref{sec:drhook} \\  
\verb|INTEGER(KIND=jpim), PARAMETER :: zhook_out = 1  ! DrHook tracing exit | & \\  
\verb|INTEGER :: i                ! Loop counter | & \\  
\verb|INTEGER :: j                ! Loop counter | & \\ 
\verb|INTEGER :: icode            ! error code for EReport| & \\ 
\verb|LOGICAL :: l_loud           ! debug flag (default false unless l_loud_opt is used)| & \ref{sec:declare}\\ 
\verb|| & \\ 
\verb|REAL, ALLOCATABLE :: field(:,:)     ! Scaling array to fill.| & \ref{sec:allocate}\\
\verb|REAL(KIND=jprb)   :: zhook_handle   ! DrHook tracing | & \ref{sec:drhook}\\  
\verb|| & \\  
\verb|CHARACTER(LEN=*), PARAMETER        :: RoutineName='EXAMPLE' | & \ref{Error reporting} \\ 
\verb|CHARACTER(LEN=errormessagelength)  :: Cmessage ! used for EReport | & \\ 
\verb|CHARACTER(LEN=256)                 :: my_char  ! string for output | & \\ 
\verb|| & \\  
\verb|! End of header| & \\  
\verb|IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_in,zhook_handle)| & \ref{sec:drhook}\\  
\verb|| & \\  
\verb|! Set debug flag if argument is present| & \\
\verb|l_loud = .FALSE.| & \\
\verb|IF (PRESENT(l_loud_opt)) THEN| & \ref{sec:declare}\\
\verb|  l_loud = l_loud_opt| & \\
\verb|END IF| & \\
\verb|| & \\
\verb|my_char                                                 &| & \ref{sec:contd} \\ 
\verb|    =  'This is a very very very very very very very '  &| & \\ 
\verb|    // 'loud character assignment'    ! A pointless long character example.| & \\ 
\verb|icode=0| & \\ 
\verb|| & \\ 
\verb|! verbosity choice, output some numbers to aid with debugging | & \ref{sec:comments}\\ 
\verb|! protected by printstatus>=PrNorm and pe=0 | & \\ 
\verb|WRITE(ummessage,'(A,I0)')'xlen=',xlen | & \ref{sec:format}\\ 
\verb|CALL umprint(ummessage,level=PrNorm,pe=0,src='example_mod') | & \ref{sec:prstatus} \\ 
\verb|WRITE(ummessage,'(A,I0)')'ylen=',ylen | & \\ 
\verb|CALL umprint(ummessage,level=PrNorm,pe=0,src='example_mod') | & \\ 
\verb|IF (l_loud) CALL umprint(my_char,level=PrNormal,src='example_mod') | & \\ 
\verb|| & \\  
\verb|! Allocate and initialise scaling array| & \ref{sec:comments}\\ 
\verb|! Noddy code warns user when scalling is not employed.  | & \\ 
\verb|IF ( l_unscale ) THEN |& \ref{sec:blocks}\\ 
\verb|  icode = -100  ! set up WARNING message | & \\
\verb|  ALLOCATE(field( 1,1 ) )|& \ref{sec:allocate}\\
\verb|  cmessage='Scaling is switched off in run!'  |& \\
\verb|  CALL ereport(RoutineName,icode,cmessage)|& \ref{Error reporting} \\
\verb|ELSE |& \\  
\verb|  ALLOCATE(field( xlen, ylen ) )|& \ref{sec:allocate}\\ 
\verb|  DO j=1,ylen | & \ref{sec:blocks} \\ 
\verb|    DO i=1,xlen | & \\ 
\verb|      field(i, j)  = (1.0*i) + (2.0*j)  | & \ref{sec:fortstyle}\\
\verb|      input2(i, j) = input2(i, j) * field(i, j) | & \\ 
\verb|    END DO  | & \\ 
\verb|  END DO  | & \\ 
\verb|END IF |& \\  
\verb|| & \\ 
\verb|! The main calculation of the routine, using OpenMP.| & \ref{sec:comments}\\
\verb|!$OMP  PARALLEL DEFAULT(NONE)                                         & |& \ref{OpenMP}\\
\verb|!$OMP  SHARED(xlen,ylen,input1,input2,field,output)                   & |& \\
\verb|!$OMP  PRIVATE(i, j )           |& \ref{OpenMP}\\
\verb|!$OMP DO SCHEDULE(STATIC) |& \\ 
\verb|DO j = 1, ylen| & \\  
\verb|  i_loop: DO i = 1, xlen| & \ref{sec:blocks} \\  
\verb|    ! Calculate the Output value:    | & \\  
\verb|    output(i, j) = (input1(i, j) * input2(i, j)) | & \\  
\verb|  END DO i_loop | & \\  
\verb|END DO ! j loop | & \\ 
\verb|!$OMP END DO| & \ref{OpenMP}\\  
\verb|!$OMP END PARALLEL | & \ref{OpenMP}\\  
\verb|| & \\  
\verb|DEALLOCATE (field) |& \ref{sec:allocate}\\  
\verb|| & \\ 
\verb|IF (lhook) CALL dr_hook(ModuleName//':'//RoutineName,zhook_out,zhook_handle)| & \ref{sec:drhook}\\  
\verb|RETURN| & \\  
\verb|END SUBROUTINE example| & \ref{sec:fortstyle}\\  
\verb|| & \\  
\verb|END MODULE example_mod| & \ref{sec:fortstyle}\\  
\end{longtable}

